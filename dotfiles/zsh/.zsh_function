## setenv (csh compatibility)
setenv() {
  typeset -x "${1}${1:+=}${(@)argv[2,$#]}"
}


## freload
freload() {
  while (( $# )); do;
    unfunction $1;
    autoload -U $1;
    shift;
  done
}


## dabbrev
# http://d.hatena.ne.jp/secondlife/20060108/1136650653
HARDCOPYFILE=$HOME/tmp/screen-hardcopy
touch $HARDCOPYFILE

dabbrev-complete () {
  local reply lines=80 # 80è¡Œåˆ†
  screen -X eval "hardcopy -h $HARDCOPYFILE"
  reply=($(sed '/^$/d' $HARDCOPYFILE | sed '$ d' | tail -$lines))
  compadd - "${reply[@]%[*/=@|]}"
}

zle -C dabbrev-complete menu-complete dabbrev-complete
bindkey '^o' dabbrev-complete
bindkey '^o^_' reverse-menu-complete


## cdd
# http://d.hatena.ne.jp/secondlife/20080218/1203303528
autoload -U compinit
compinit
source $HOME/bin/cdd

add-zsh-hook chpwd _reg_pwd_screennum


## ssh_screen
function ssh_screen() {
  eval server=\${$#}
    screen -t $server ssh "$@"
}
if [ x$TERM = x$TERMSCREEN ]; then
  alias ssh=ssh_screen
fi


# for screen status line
if [ "$TERM" = $TERMSCREEN ]; then
  #chpwd () {
  _update_screen_title_by_cd () {
    echo -n "_`dirs`\\"
  }
  add-zsh-hook chpwd _update_screen_title_by_cd

  #preexec() {
  _update_screen_title_by_command () {
    # see [zsh-workers:13180]
    # http://www.zsh.org/mla/workers/2000/msg03993.html
    emulate -L zsh
    local -a cmd; cmd=(${(z)2})
    case $cmd[1] in
      fg)
      if (( $#cmd == 1 )); then
        cmd=(builtin jobs -l %+)
      else
        cmd=(builtin jobs -l $cmd[2])
      fi
      ;;
      %*)
      cmd=(builtin jobs -l $cmd[1])
      ;;
      cd)
      if (( $#cmd == 2)); then
        cmd[1]=$cmd[2]
      fi
      ;;
      *)
      echo -n "k$cmd[1]:t\\"
      prev=$cmd[1]
      return
      ;;
    esac

    local -A jt; jt=(${(kv)jobtexts})

    $cmd >>(read num rest
    cmd=(${(z)${(e):-\$jt$num}})
    echo -n "k$cmd[1]:t\\") 2>/dev/null

    prev=$cmd[1]
  }
  add-zsh-hook preexec _update_screen_title_by_command

  #precmd() {
  _update_screen_title() {
    #local prev; prev=`history -1 | sed "s/^[ 0-9]*//" | sed "s/ .*$//"`
    echo -n "k$:$prev\\"
  }
  add-zsh-hook precmd _update_screen_title

  #chpwd
  _update_screen_title_by_cd
fi


## Phil!'s ZSH Prompt
# http://aperiodic.net/phil/prompt/
##function precmd {
#function _phil_prompt {
#local TERMWIDTH
#(( TERMWIDTH = ${COLUMNS} - 1 ))
#
####
## Truncate the path if it's too long.
#PR_FILLBAR=""
#PR_PWDLEN=""
#
#local promptsize=${#${(%):---(%n@%m:%l)---()--}}
#local pwdsize=${#${(%):-%~}}
#
#if [[ "$promptsize + $pwdsize" -gt $TERMWIDTH ]]; then
#  ((PR_PWDLEN=$TERMWIDTH - $promptsize))
#else
#  PR_FILLBAR="\${(l.(($TERMWIDTH - ($promptsize + $pwdsize)))..${PR_HBAR}.)}"
#fi
#
####
## Get APM info.
#if which ibam > /dev/null; then
#  PR_APM_RESULT=`ibam --percentbattery`
#elif which apm > /dev/null; then
#  PR_APM_RESULT=`apm`
#fi
#}
#add-zsh-hook precmd _phil_prompt
#
##setopt extended_glob
##preexec () {
##  if [[ "$TERM" == "screen" ]]; then
##    local CMD=${1[(wr)^(*=*|sudo|-*)]}
##    echo -n "\ek$CMD\e\\"
##  fi
##}
#
#setprompt () {
#  ###
#  # Need this so the prompt will work.
#  setopt prompt_subst
#
#  ###
#  # See if we can use colors.
#  autoload colors zsh/terminfo
#  if [[ "$terminfo[colors]" -ge 8 ]]; then
#    colors
#  fi
#  for color in RED GREEN YELLOW BLUE MAGENTA CYAN WHITE; do
#    eval PR_$color='%{$terminfo[bold]$fg[${(L)color}]%}'
#    eval PR_LIGHT_$color='%{$fg[${(L)color}]%}'
#    (( count = $count + 1 ))
#  done
#  PR_NO_COLOUR="%{$terminfo[sgr0]%}"
#
#  ###
#  # See if we can use extended characters to look nicer.
#  typeset -A altchar
#  set -A altchar ${(s..)terminfo[acsc]}
#  PR_SET_CHARSET="%{$terminfo[enacs]%}"
#  PR_SHIFT_IN="%{$terminfo[smacs]%}"
#  PR_SHIFT_OUT="%{$terminfo[rmacs]%}"
#  PR_HBAR=${altchar[q]:--}
#  PR_ULCORNER=${altchar[l]:--}
#  PR_LLCORNER=${altchar[m]:--}
#  PR_LRCORNER=${altchar[j]:--}
#  PR_URCORNER=${altchar[k]:--}
#
#  ###
#  # Decide if we need to set titlebar text.
#  case $TERM in
#    xterm*)
#    PR_TITLEBAR=$'%{\e]0;%(!.-=*[ROOT]*=- | .)%n@%m:%~ | ${COLUMNS}x${LINES} | %y\a%}'
#    ;;
#    screen)
#    PR_TITLEBAR=$'%{\e_screen \005 (\005t) | %(!.-=[ROOT]=- | .)%n@%m:%~ | ${COLUMNS}x${LINES} | %y\e\\%}'
#    ;;
#    *)
#    PR_TITLEBAR=''
#    ;;
#  esac
#
#  ###
#  # Decide whether to set a screen title
#  if [[ "$TERM" == "screen" ]]; then
#    PR_STITLE=$'%{\ekzsh\e\\%}'
#  else
#    PR_STITLE=''
#  fi
#
#  ###
#  # APM detection
#  if which ibam > /dev/null; then
#    PR_APM='$PR_RED${${PR_APM_RESULT[(f)1]}[(w)-2]}%%(${${PR_APM_RESULT[(f)3]}[(w)-1]})$PR_LIGHT_BLUE:'
#  elif which apm > /dev/null; then
#    PR_APM='$PR_RED${PR_APM_RESULT[(w)5,(w)6]/\% /%%}$PR_LIGHT_BLUE:'
#  else
#    PR_APM=''
#  fi
#
#  ###
#  # Finally, the prompt.
#  PROMPT='$PR_SET_CHARSET$PR_STITLE${(e)PR_TITLEBAR}\
#  $PR_CYAN$PR_SHIFT_IN$PR_ULCORNER$PR_BLUE$PR_HBAR$PR_SHIFT_OUT(\
#  $PR_GREEN%(!.%SROOT%s.%n)$PR_GREEN@%m:%l\
#  $PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_CYAN$PR_HBAR${(e)PR_FILLBAR}$PR_BLUE$PR_HBAR$PR_SHIFT_OUT(\
#  $PR_MAGENTA%$PR_PWDLEN<...<%~%<<\
#  $PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_CYAN$PR_URCORNER$PR_SHIFT_OUT\
#
#  $PR_CYAN$PR_SHIFT_IN$PR_LLCORNER$PR_BLUE$PR_HBAR$PR_SHIFT_OUT(\
#  %(?..$PR_LIGHT_RED%?$PR_BLUE:)\
#  ${(e)PR_APM}$PR_YELLOW%D{%H:%M}\
#  $PR_LIGHT_BLUE:%(!.$PR_RED.$PR_WHITE)%#$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
#  $PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
#  $PR_NO_COLOUR '
#
#  RPROMPT=' $PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_BLUE$PR_HBAR$PR_SHIFT_OUT\
#  ($PR_YELLOW%D{%a,%b%d}$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_CYAN$PR_LRCORNER$PR_SHIFT_OUT$PR_NO_COLOUR'
#
#  PS2='$PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
#  $PR_BLUE$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT(\
#  $PR_LIGHT_GREEN%_$PR_BLUE)$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT\
#  $PR_CYAN$PR_SHIFT_IN$PR_HBAR$PR_SHIFT_OUT$PR_NO_COLOUR '
#}
#
#setprompt
