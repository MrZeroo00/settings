## autoload
# Where to look for autoloaded function definitions
#fpath=($fpath ${HOME}/.zsh/function)

# Autoload all shell functions from all directories in $fpath (following
# symlinks) that have the executable bit on (the executable bit is not
# necessary, but gives you an easy way to stop the autoloading of a
# particular shell function). $fpath should not be empty for this to work.
for func in $^fpath/*(N-.x:t); autoload $func


autoload -U add-zsh-hook
#autoload predict-on
#predict-on
#autoload zed
autoload -U edit-command-line
zle -N edit-command-line
bindkey "^O" edit-command-line
#history-register-line () { fc -R <(<<<$BUFFER); zle send-break }
#zle -N history-register-line


## cdr system stuff.
if is-at-least 4.3.11; then
  autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
  add-zsh-hook chpwd chpwd_recent_dirs
  zstyle ':chpwd:*' recent-dirs-max 5000
  zstyle ':chpwd:*' recent-dirs-default yes
  zstyle ':completion:*' recent-dirs-insert both
fi


## change prompt color by return value
if [ -z "${EMACS}" ]; then
  autoload -U colors
  colors
  PROMPT="%{$fg[green]%}$LPROMPT%{$reset_color%}"
  _change_prompt_color_by_return_value () {
    PROMPT="%{%(?.$fg[green].$fg[red])%}$LPROMPT%{$reset_color%}"
  }
  add-zsh-hook precmd _change_prompt_color_by_return_value
fi


## display vcs info in right prompt
autoload -Uz vcs_info
zstyle ':vcs_info:*' formats '(%s)-[%b]'
zstyle ':vcs_info:*' actionformats '(%s)-[%b|%a]'
_set_vcs_info () {
  psvar=()
  LANG=en_US.UTF-8 vcs_info
  [[ -n "$vcs_info_msg_0_" ]] && psvar[1]="$vcs_info_msg_0_"
}
add-zsh-hook precmd _set_vcs_info
RPROMPT="%1(v|%F{green}%1v%f|)"


## git-completion
autoload bashcompinit
source ${HOME}/.zsh/function/git-completion.bash

## Phil!'s ZSH Prompt
#source ${HOME}/.zsh/function/phil_prompt.sh
#add-zsh-hook precmd _phil_prompt
#setprompt


## magic-abbrev-expand
source ${HOME}/.zsh/function/magic-abbrev-expand.sh
#zle -N magic-abbrev-expand
#zle -N no-magic-abbrev-expand
#bindkey " " magic-abbrev-expand
#bindkey "^x " no-magic-abbrev-expand


## dabbrev-complete
source ${HOME}/.zsh/function/dabbrev-complete.sh
zle -C dabbrev-complete menu-complete dabbrev-complete
bindkey '^o' dabbrev-complete
bindkey '^o^_' reverse-menu-complete


## autojump
# https://github.com/joelthelion/autojump
source ${HOME}/.zsh/function/autojump/etc/profile.d/autojump.zsh


## cdd
# http://d.hatena.ne.jp/secondlife/20080218/1203303528
#autoload -U compinit
#compinit
source ${HOME}/.zsh/function/cdd.sh
add-zsh-hook chpwd _reg_pwd_screennum


## view/edit-file
source ${HOME}/.zsh/function/view-edit-file.sh
#zle -N view-file
#bindkey "^x^r" view-file
#zle -N edit-file
#bindkey "^x^f" edit-file


## ssh_screen
function ssh_screen() {
  eval server=\${$#}
    screen -t $server ssh -t "$@"
}
#if [ "${TERM}" = "${TERMSCREEN}" ]; then
#  alias ssh=ssh_screen
#fi


# for screen status line
if [ "${TERM}" = "${TERMSCREEN}" ]; then
  #preexec() {
  _update_screen_title_by_command () {
    # see [zsh-workers:13180]
    # http://www.zsh.org/mla/workers/2000/msg03993.html
    emulate -L zsh
    local -a cmd; cmd=(${(z)2})
    case $cmd[1] in
      fg)
      if (( $#cmd == 1 )); then
        cmd=(builtin jobs -l %+)
      else
        cmd=(builtin jobs -l $cmd[2])
      fi
      ;;
      %*)
      cmd=(builtin jobs -l $cmd[1])
      ;;
      cd)
      if (( $#cmd == 2)); then
        cmd[1]=$cmd[2]
      fi

      # my patch
      echo -n "k$cmd[1]:t\\"
      return
      ;;
      *)
      echo -n "k$cmd[1]:t\\"
      #prev=$cmd[1]
      return
      ;;
    esac

    local -A jt; jt=(${(kv)jobtexts})

    $cmd >>(read num rest
    cmd=(${(z)${(e):-\$jt$num}})
    echo -n "k$cmd[1]:t\\") 2>/dev/null

    #prev=$cmd[1]
  }
  add-zsh-hook preexec _update_screen_title_by_command
fi


## setenv (csh compatibility)
setenv() {
  typeset -x "${1}${1:+=}${(@)argv[2,$#]}"
}


## freload
freload() {
  while (( $# )); do;
    unfunction $1;
    autoload -U $1;
    shift;
  done
}


# local setting
if [ -f ${HOME}/.zsh_function.`hostname -s`.local ]; then
  source ${HOME}/.zsh_function.`hostname -s`.local
fi
