if [ -f ${HOME}/.sh_function ]; then
    source ${HOME}/.sh_function
fi

## autoload
# Where to look for autoloaded function definitions
#fpath=($fpath ${HOME}/.zsh/function)

# Autoload all shell functions from all directories in $fpath (following
# symlinks) that have the executable bit on (the executable bit is not
# necessary, but gives you an easy way to stop the autoloading of a
# particular shell function). $fpath should not be empty for this to work.
for func in $^fpath/*(N-.x:t); autoload $func


autoload -Uz is-at-least
autoload -U add-zsh-hook
#autoload predict-on
#predict-on
#autoload zed
autoload -U edit-command-line
zle -N edit-command-line
bindkey "^O" edit-command-line
#history-register-line () { fc -R <(<<<$BUFFER); zle send-break }
#zle -N history-register-line

zstyle ':completion:*' menu select=2
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion:*:descriptions' format '%BCompleting%b %U%d%u'
typeset -ga chpwd_functions

## change prompt color by return value
# comment out temporally
#if [ -z "${EMACS}" ]; then
#  autoload -U colors
#  colors
#  PROMPT="%{$fg[green]%}$LPROMPT%{$reset_color%}"
#  _change_prompt_color_by_return_value () {
#    PROMPT="%{%(?.$fg[green].$fg[red])%}$LPROMPT%{$reset_color%}"
#  }
#  add-zsh-hook precmd _change_prompt_color_by_return_value
#fi


## display vcs info in right prompt
#autoload -Uz vcs_info
#zstyle ':vcs_info:*' formats '(%s)-[%b]'
#zstyle ':vcs_info:*' actionformats '(%s)-[%b|%a]'
#_set_vcs_info () {
#  psvar=()
#  LANG=en_US.UTF-8 vcs_info
#  [[ -n "$vcs_info_msg_0_" ]] && psvar[1]="$vcs_info_msg_0_"
#}
#add-zsh-hook precmd _set_vcs_info
#RPROMPT="%1(v|%F{green}%1v%f|)"


# show vi mode
autoload -Uz colors; colors
autoload -Uz add-zsh-hook
autoload -Uz terminfo

terminfo_down_sc=$terminfo[cud1]$terminfo[cuu1]$terminfo[sc]$terminfo[cud1]
left_down_prompt_preexec() {
  print -rn -- $terminfo[el]
}
add-zsh-hook preexec left_down_prompt_preexec

function zle-keymap-select zle-line-init zle-line-finish
{
  case $KEYMAP in
    main|viins)
      PROMPT_2="$fg[cyan]-- INSERT --$reset_color"
      ;;
    vicmd)
      PROMPT_2="$fg[white]-- NORMAL --$reset_color"
      ;;
    vivis|vivli)
      PROMPT_2="$fg[yellow]-- VISUAL --$reset_color"
      ;;
  esac

  PROMPT="%{$terminfo_down_sc$PROMPT_2$terminfo[rc]%}[%(?.%{${fg[green]}%}.%{${fg[red]}%})%n%{${reset_color}%}]%# "
  zle reset-prompt
}

zle -N zle-line-init
zle -N zle-line-finish
zle -N zle-keymap-select
zle -N edit-command-line

function history-all { history -E 1 }

## percol
source ${HOME}/.zsh/function/percol

## fzf
source ${HOME}/.zsh/function/fzf

## magic-abbrev-expand
source ${HOME}/.zsh/function/magic-abbrev-expand.sh
#zle -N magic-abbrev-expand
#zle -N no-magic-abbrev-expand
#bindkey " " magic-abbrev-expand
#bindkey "^x " no-magic-abbrev-expand


## dabbrev-complete
source ${HOME}/.zsh/function/dabbrev-complete.sh
zle -C dabbrev-complete menu-complete dabbrev-complete
bindkey '^o' dabbrev-complete
bindkey '^o^_' reverse-menu-complete


## cdd
# http://d.hatena.ne.jp/secondlife/20080218/1203303528
CDD_FILE=${HOME}/.zsh/cdd_pwd_list
source ${HOME}/.zsh/function/cdd/cdd
chpwd_functions+=_cdd_chpwd


## view/edit-file
source ${HOME}/.zsh/function/view-edit-file.sh
#zle -N view-file
#bindkey "^x^r" view-file
#zle -N edit-file
#bindkey "^x^f" edit-file


## zaw
# https://github.com/zsh-users/zaw
source ${HOME}/.zsh/function/zaw/zaw.zsh
zstyle ':filter-select' case-insensitive yes
bindkey '^S' zaw-cdr


## notify-command-exit
# http://qiita.com/hayamiz/items/d64730b61b7918fbb970
source ${HOME}/.zsh/function/notify-command-exit.sh


## ssh_screen
function ssh_screen() {
  eval server=\${$#}
    screen -t $server ssh -t "$@"
}
#if [ "${TERM}" = "${TERMSCREEN}" ]; then
#  alias ssh=ssh_screen
#fi


# for screen status line
#if [ "${TERM}" = "${TERMSCREEN}" ]; then
#  #preexec() {
#  _update_screen_title_by_command () {
#    # see [zsh-workers:13180]
#    # http://www.zsh.org/mla/workers/2000/msg03993.html
#    emulate -L zsh
#    local -a cmd; cmd=(${(z)2})
#    case $cmd[1] in
#      fg)
#      if (( $#cmd == 1 )); then
#        cmd=(builtin jobs -l %+)
#      else
#        cmd=(builtin jobs -l $cmd[2])
#      fi
#      ;;
#      %*)
#      cmd=(builtin jobs -l $cmd[1])
#      ;;
#      cd)
#      if (( $#cmd == 2)); then
#        cmd[1]=$cmd[2]
#      fi
#
#      # my patch
#      echo -n "k$cmd[1]:t\\"
#      return
#      ;;
#      *)
#      echo -n "k$cmd[1]:t\\"
#      #prev=$cmd[1]
#      return
#      ;;
#    esac
#
#    local -A jt; jt=(${(kv)jobtexts})
#
#    $cmd >>(read num rest
#    cmd=(${(z)${(e):-\$jt$num}})
#    echo -n "k$cmd[1]:t\\") 2>/dev/null
#
#    #prev=$cmd[1]
#  }
#  add-zsh-hook preexec _update_screen_title_by_command
#fi


## setenv (csh compatibility)
setenv() {
  typeset -x "${1}${1:+=}${(@)argv[2,$#]}"
}


## freload
freload() {
  while (( $# )); do;
    unfunction $1;
    autoload -U $1;
    shift;
  done
}


## zman
function zman() {
  PAGER="less -g -s '+/^       "$1"'" man zshall
}


# local setting
if [ -f ${HOME}/.zsh/.zsh_function.`hostname -s`.local ]; then
  source ${HOME}/.zsh/.zsh_function.`hostname -s`.local
fi
